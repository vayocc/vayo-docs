这边使用spring的线程池`ThreadPoolTaskExecutor`

- **`corePoolSize`**： 线程池维护线程的最少数量 （这些线程始终存活，不会因为空闲而被终止，除非显式调用了`shutdown()`方法来关闭线程池。）
- **`maxPoolSize`**：线程池维护线程的最大数量 （当任务量超过核心线程处理能力时，线程池会创建非核心线程（直到最大线程数）。这些线程在完成任务后，如果在`keepAliveSeconds`内没有新的任务到来，会被终止。）
- **`keepAliveSeconds`**： 线程池维护线程所允许的空闲时间  如：这个线程不是核心线程（即超过核心线程数的那些线程），并且在300秒内没有接收到新的任务，那么这个线程就会被终止。
- unit： 线程池维护线程所允许的空闲时间的单位
- **`queueCapacity`**： 设置任务队列的容量，超过这个容量的任务会根据拒绝策略进行处理。
- **`rejectedExecutionHandler`**： 线程池对拒绝任务的处理策略

**线程池工作机制**

线程池在执行任务时，大致遵循以下步骤：

1. **核心线程数**：首先，线程池会使用核心线程数（corePoolSize）来处理任务。
2. **任务队列**：当所有核心线程都在忙碌时，新的任务会被放入任务队列中等待执行。
3. **最大线程数**：当任务队列已满，且所有核心线程也在忙碌时，线程池会尝试创建新线程，直到线程数达到最大线程数（maximumPoolSize）。
4. **拒绝策略**：如果线程池的线程数已达到最大线程数，且任务队列也已满，则会根据拒绝策略处理新提交的任务。

**handler有四个选择**

ThreadPoolExecutor.AbortPolicy() ：抛出java.util.concurrent.RejectedExecutionException异常

ThreadPoolExecutor.CallerRunsPolicy() : 重试添加当前的任务，他会自动重复调用execute()方法

ThreadPoolExecutor.DiscardOldestPolicy() : 抛弃旧的任务

ThreadPoolExecutor.DiscardPolicy() : 抛弃当前的任务

> 执行流程示例 (如果核心8 最大核心16 队列1000)
>
> 1. **0到8个任务**：这些任务会直接由核心线程处理。
> 2. **第9到第1008个任务**：如果核心线程数已经达到8且都在处理任务，新任务会被放入任务队列中等待执行。
> 3. **第1009到第1016个任务**：当任务队列已满（1000个任务在队列中等待），且核心线程数已达8，新任务会触发创建新线程（最多增加到16个线程）。
> 4. **超过1016个任务**：当线程池已达到最大线程数（16个线程），且任务队列已满，新的任务会根据拒绝策略处理（在这个配置中，由调用者线程执行）。